---
title: Directional Analysis
subtitle: Putting polar plots on an interactive map 
author: Jack Davison
abstract: "One of the headline features of `openairmaps` is creating maps using directional analysis plots as markers. Being able to place a polar plot or similar visualisation on a map can allow us to gain additional insight from our analysis, permitting us to easily compare different sites and further understand their geographic context. This page introduces the `polarMap()` family of functions, and the suite of customisations available to users."
execute: 
  cache: false
---

## Data Requirements

[openairmaps]{.pkg} contains the `polar_data` dataset to allow users to test the directional analysis functions. The structure of this data set is provided below, and a summary is given in @tbl-polardata. The important feature of this data when compared to `openair::mydata` is latitude and longitude information, which [openairmaps]{.pkg} needs to place the directional analysis markers in the correct positions.

```{r}
#| label: glimpsePolar
library(openairmaps)
dplyr::glimpse(polar_data)
```

```{r}
#| label: tbl-polardata
#| echo: false
#| tbl-cap: "A statistical summary of the `polar_data` dataset."
polar_data %>%
  dplyr::select(-site_type) %>%
  gtsummary::tbl_summary(
    missing = "no", 
    by = "site",
    type = list(lat ~ "continuous", lon ~ "continuous"),
    statistic = list(lat ~ "{median}", lon ~ "{median}")
  )
```

If you would prefer to use data from different sites or years, the `import*()` functions from [openair]{.pkg} make it easy to obtain pollution data with associated site latitude/longitude. The key thing to remember is to use the `meta = TRUE` argument when using a function like `importAURN()` to have the lat/lon (& site type) appended to your imported data.

```{r}
#| label: importlatlon
sunderland <- openair::importAURN(site = c("sun2", "sunr"), year = 2015, meta = TRUE)
names(sunderland)
```

By "directional analysis", we are referring to the outputs from [openair]{.pkg} functions like `polarPlot`. As a reminder as to what these figures look like, see @fig-openairplots.

```{r}
#| label: fig-openairplots
#| fig-cap: "All of the directional analysis figures which can be plotted on a map."
#| fig-subcap: 
#| - "Polar Annulus"
#| - "Polar Frequency"
#| - "Percentile Rose"
#| - "Polar Plot"
#| - "Pollution Rose"
#| - "Wind Rose"
#| layout-ncol: 3
openair::polarAnnulus(polar_data)
openair::polarFreq(polar_data)
openair::percentileRose(polar_data)
openair::polarPlot(polar_data)
openair::pollutionRose(polar_data)
openair::windRose(polar_data)
```

## Overview

The easiest way to get polar plots on a map is through the use of the all-in-one mapping functions. These are all named using the pattern `{function-name}Map`, where `{function_name}` is a short hand for the equivalent [openair]{.pkg} function. A reference is provided in @tbl-dirAnalysisRef.

```{r}
#| label: tbl-dirAnalysisRef
#| echo: false
#| tbl-cap: "A reference table for `openairmaps` directional analysis mapping functions."
dplyr::tribble(
  ~ openair,          ~ openairmaps,     ~`scale arguments`, ~ `unique arguments`,
  "`polarAnnulus()`",   "`annulusMap()`",    "`limits`",         "`period`",
  "`polarFreq()`",      "`freqMap()`",       "`breaks`",         "`statistic`",
  "`percentileRose()`", "`percentileMap()`", "`percentile`",     "--",
  "`polarPlot()`",      "`polarMap()`",      "`limits`",         "`x`",
  "`pollutionRose()`",  "`pollroseMap()`",   "`breaks`",         "`statistic`",
  "`windRose()`",       "`windroseMap()`",   "`ws.int`, `breaks`",  "--"
) %>%
  gt::gt() %>%
  gt::fmt_markdown(everything())
```

Effectively all of these functions have very similar arguments, although some are unique to the specific function (also shown in @tbl-dirAnalysisRef). The important ones to pay attention to are:

-   `data`: The data you would like to map. Ensure that lat/lon information is present.

-   `pollutant`: The pollutant(s) of interest. If multiple pollutants are provided, a "layer control" menu will allow readers to swap between them.

-   `latitude`, `longitude`: The lat/lon column names. If they are not specified, the functions will attempt to guess them based on common names (e.g., "lon", "lng", "long" and "longitude" for `longitude`).

-   `control`: A column to use to create a "layer control" menu. Specifying `control` effectively splits the input data along the specified column, creating multiple separate sets of directional analysis plots. Common columns to pass to `control` will be those created by `openair::cutData()` or `openair::splitByDate()`.[^maps-polar-1]

[^maps-polar-1]: Note that maps can only have one "layer control" menu. Users should therefore only provide multiple pollutants *or* an argument to `control`, but never both. If multiple pollutants *and* `control` are specified, `control` will be ignored.

-   `popup`: A column to be used to create a HTML "popup" that appears when users click the markers. This would be useful to label each marker with its corresponding site name or code, although other information could be usefully included (e.g., site type, average pollutant concentrations, and so on). A more complicated popup can be created using the `buildPopup()` function.

-   `label`: Much the same as "popup", but the message will appear when users hover-over the marker rather than click on it. Labels are often much shorter than popups.

-   `provider`: The [leaflet]{.pkg} base map provider(s) you'd like to use. If multiple providers are provided, a "layer control" menu will allow readers to swap between them. Note that you can provide multiple pollutants *and* providers!

-   The "scale arguments" (e.g., `limits` for `polarMap()`). By specifying a scale, all polar markers will use the same colour scale, making them quantitatively comparable to one another. Specifying a scale will also draw a shared legend at the top-right of the plot, unless `draw.legend` is set to `FALSE`.

-   `...`: Any additional arguments to pass to the equivalent [openair]{.pkg} function.


## Simple Demonstrations

`polarMap()` is demonstrated in @fig-polarMap. Try clicking on each of the markers to see which sites they correspond to.

```{r}
#| label: fig-polarMap
#| fig-cap: "A demonstration of `polarMap()`."
polarMap(
  polar_data,
  pollutant = "nox",
  latitude = "lat",
  longitude = "lon",
  popup = "site"
)
```

Another example, this time using `annulusMap()`, is given in @fig-annulusMap. Note that this time there are two different pollutants plotted, which can be swapped between using the layer control menu. [openairmaps]{.pkg} automatically deals with subscripts in common pollutant names.

```{r}
#| label: fig-annulusMap
#| fig-cap: "A more complex demonstration, this time using `annulusMap()`."
annulusMap(
  polar_data,
  pollutant = c("nox", "no2"), 
  provider = "CartoDB.Positron",
  latitude = "lat",
  longitude = "lon"
)
```

## Colour Scales

@fig-polarMap could be described as using `polarMap()` in a "qualitative" mode --- each site is using its own colour scale, so they cannot be easily compared quantitatively. There are two ways to use `polarMap()` in a more "quantitative" way:

1.  Use the appropriate "scale" argument to set a colour scale that all markers will share. For `polarMap()` (and `annulusMap()`) this is the "limits" argument, which works the same way as in `polarPlot()` (and `annulusPlot()`). In fact, all of the "scales" arguments shown in @tbl-dirAnalysisRef work in the exact same way as their corresponding [openair]{.pkg} function. Setting a shared scale will draw an easy-to-read shared legend, which can be disabled using the `draw.legend` argument.

2.  Set the `key` argument to be `TRUE`, which will draw the colour bar next to each individual marker. This may be advantageous if one site is much more polluted compared to another one, but the individual colour bars can be confusing and difficult to read depending on the chosen base map.

::: {.panel-tabset}

###  Shared Scale

```{r}
#| label: fig-polarMapShare
#| fig-cap: "A demonstration of `polarMap()` with a shared colour scale."
polarMap(
  polar_data,
  pollutant = "nox",
  latitude = "lat",
  longitude = "lon",
  popup = "site",
  limits = c(0, 500)
)
```

###  Distinct Scales

```{r}
#| label: fig-polarMapDistinct
#| fig-cap: "A demonstration of `polarMap()` with individual colour scales."
polarMap(
  polar_data,
  pollutant = "nox",
  latitude = "lat",
  longitude = "lon",
  popup = "site",
  key = TRUE
)
```

:::

## Use of `control`

A third example is shown in @fig-controlMap. This uses `percentileMap()` and demonstrates how to use the "control" option to create a custom "layer control" menu and "label" and "popup" to label the markers, as well as passing on arguments to the equivalent [openair]{.pkg} function --- in this case, passing the "intervals" argument to `percentileRose()` so that all of the markers are on the same radial axis.

```{r}
#| label: fig-controlMap
#| fig-cap: "A demonstration of `percentileMap()` using the 'control' option and passing arguments to `openair::percentileRose()`."
polar_data %>%
  openair::cutData("weekend") %>% 
  percentileMap(
    pollutant = "nox",
    control = "weekend",
    latitude = "lat",
    longitude = "lon", 
    provider = "Esri.WorldTopoMap",
    cols = "viridis",
    popup = "site",
    label = "site_type",
    intervals = c(0, 200, 400, 600, 800, 1000)
  )
```

## Building Popups

So far, popups have used a single column to label the markers, but you will often want to encode more data than just the site name or type. For example, you may want to use the site name *and* type *and* the average wind speed *and* the dates it was active! To do so, you can use the `buildPopup()` function. This function has a handful of arguments:

-  `data`: the data you are going to use with, e.g., `polarMap()`.

-  `cols`: the columns you would like to encode in your popup.

-  `latitude` & `longitude`: the decimal latitude/longitude, which `buildPopup()` will use to identify individual sites to create labels for.

-  `names`: a named vector used to rename columns in the popup.

-  `control`: optional. This should only be used if you are going to use the `control` option in, e.g., `polarMap()` and you'd expect different popups for the different layers (i.e., it isn't needed for site names/types, but it is needed for pollutant concentrations).

-  `fun.character`, `fun.numeric` & `fun.dttm`: the functions used to summarise character/factor, numeric, and date-time columns. These have nice defaults, but you may wish to override them.

Think of `buildPopup()` as an intermediate between your data and the polar mapping function. All it does on its own is return the input data with a "popup" column appended, which can then be used with the `popup` argument of the mapping function. @fig-buildPopup demonstrates the use of `buildPopup()` --- try swapping between the layers and clicking on each of the markers.

```{r}
#| label: fig-buildPopup
#| fig-cap: "A demonstration of the `buildPopup()` function."
#| message: false
#| warning: false
polar_data %>%
  openair::cutData("weekend") %>%
  buildPopup(
    cols = c("site", "site_type", "date", "nox"),
    names = c(
      "Site" = "site",
      "Site Type" = "site_type",
      "Date Range" = "date",
      "Average nox" = "nox"
    ),
    control = "weekend"
  ) %>%
  pollroseMap(pollutant = "nox",
              popup = "popup",
              breaks = 6,
              control = "weekend")
```

## Marker Function

The directional analysis marker function is `addPolarMarkers()`, which behaves similarly (but not identically) to `leaflet::addMarkers()`. You will need to define the `data` you're using, the `lat`/`lng`[^maps-polar-2] columns, a column to distinguish different sites (`type`), and an [openair]{.pkg} function (`fun`). As with `leaflet::addMarkers()` and similar functions, you can define `group` and `layerId`, which allows you to create more complex maps than can be achieved using the all-in-one [openairmaps]{.pkg} functions.

[^maps-polar-2]: Marker functions use "lat" and "lng" as argument names for consistency with the leaflet package.

To demonstrate, @fig-polarFreqMap has been created. This uses the `polarFreq()` function to plot multiple polar pollutant frequency plots for oxides of nitrogen. What is different about this map is that users can select the specific statistic they are interested in -- in this case, mean, median or maximum. This is achieved by using the `group` arguments and `addLayersControl()`.

```{r}
#| label: fig-polarFreqMap
#| fig-cap: "Using `addPolarMarkers` to create a more complex map."
library(leaflet)
library(openair)
leaflet() %>%
  addProviderTiles(
    "Stamen.Toner"
  ) %>% 
  addPolarMarkers(
    lng = "lon", lat = "lat",
    pollutant = "nox",
    group = "Mean",
    data = polar_data,
    fun = polarFreq,
    statistic = "mean"
  ) %>% 
  addPolarMarkers(
    lng = "lon", lat = "lat",
    pollutant = "nox",
    group = "Median",
    data = polar_data,
    fun = polarFreq,
    statistic = "median"
  ) %>% 
  addPolarMarkers(
    lng = "lon", lat = "lat",
    pollutant = "nox",
    group = "Max",
    data = polar_data,
    fun = polarFreq,
    statistic = "max"
  ) %>%
  addLayersControl(
    baseGroups = c("Mean", "Median", "Max")
  )
```

One could imagine different applications, using this approach. For example:

-   Giving users the option to swap between different `period`s for a `polarAnnulus()` map, or different polar coordinates in a `polarPlot()` map (i.e., different `x` arguments).

-   Allowing users to swap between different plot types (e.g., have "Wind Rose", "Pollution Rose" and "Polar Plot" on the layer control menu).

The options are pretty much endless for the kinds of things you could achieve using this approach. If one of the all-in-one functions doesn't give you the flexibility you need, try to see if you can create your vision yourself from scratch using [leaflet]{.pkg} and the `addPolarMarkers()` function.

